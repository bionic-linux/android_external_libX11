# vim: set expandtab shiftwidth=2 tabstop=8 textwidth=0 filetype=yaml:
#
{# This here is the template file to edit, ignore the warning below #}
# WARNING: THIS FILE IS GENERATED, DO NOT EDIT
#
# This pipeline builds the given libX* project and all its dependencies.
# Use in the dependent project like this:
#
# libXi:
#   stage: build
#   trigger:
#     include:
#       - project: xorg/lib/libX11
#         ref: master
#         file: .gitlab-ci/build-libXall.yml
#     strategy: depend
#   variables:
#     PROJECT_NAME: $CI_PROJECT_NAME
#
# The job name and stage name don't matter. PROJECT_NAME must be passed
# through.
#


# This CI uses the freedesktop.org ci-templates.
# Please see the ci-templates documentation for details:
# https://freedesktop.pages.freedesktop.org/ci-templates/
.templates_sha: &template_sha c7702b1ae8507c5d5f34edcbf280f287ab541e8e # see https://docs.gitlab.com/ee/ci/yaml/#includefile


include:
  # Arch container builder template
  - project: 'freedesktop/ci-templates'
    ref: *template_sha
    file: '/templates/arch.yml'


stages:
  - sanity check
  - prep             # prep work like rebuilding the container images if there is a change
# Stages for the trigger jobs
{% for lib in libraries %}
  - {{lib.name}}
{% endfor %}


# Note: this pipeline is triggered from a different project and will inherit
# variable names from the parent pipeline. So we need to work around those
variables:
  OUR_UPSTREAM_REPO: 'xorg/lib/$PROJECT_NAME'
  # The tag should be updated each time the list of packages is updated.
  # Changing a tag forces the associated image to be rebuilt.
  # Note: the tag has no meaning, we use a date format purely for readability
  OUR_DISTRIBUTION_TAG: 'libXall-2020-11-24.2'
  # The package list is the list of all requires from all libX*, excluding the various libX* themselves
  OUR_DISTRIBUTION_PACKAGES: 'git gcc pkgconf autoconf automake make xorg-util-macros xtrans xorgproto libxcb {{libraries|selectattr("dependencies")|sum(attribute="dependencies", start=[])|unique|join(' ')}}'


#
# We require PROJECT_NAME to be passed in from whatever triggers the pipeline
#
sanity check:
  stage: sanity check
  script:
    - |
      if [ x"$PROJECT_NAME" == x ]; then
        echo "PROJECT_NAME must be passed as variable from the triggering job";
        exit 1;
      fi
    - echo "Running pipeline for $PROJECT_NAME"

#
# This job is only run if the passed-in PROJECT_NAME doesn't match any of our libraries
#
fail for unknown project name:
  stage: sanity check
  script:
    - echo "Unknown PROJECT_NAME $PROJECT_NAME"
    - exit 1;
  rules:
    - if: $PROJECT_NAME =~ /{{libraries|join('|', attribute='name')}}/i
      when: never


#
# Build a container with the given tag and the packages pre-installed.
# This only happens if when the tag changes, otherwise the existing image is
# re-used.
#
# We only run this job for libX11 - the tag cannot change without updating the
# libX11 repo anyway.
#
container-prep:
  extends:
    - .fdo.container-build@arch
  stage: prep
  variables:
    GIT_STRATEGY: none
    FDO_DISTRIBUTION_PACKAGES: $OUR_DISTRIBUTION_PACKAGES
    FDO_DISTRIBUTION_TAG: $OUR_DISTRIBUTION_TAG
    FDO_UPSTREAM_REPO: $OUR_UPSTREAM_REPO
  rules:
    - if: $PROJECT_NAME =~ /libX11/i


#
# Build template for all jobs:
# For dependencies, the PROJECT_NAME differs from the CI_JOB_NAME
# and we clone the dependency's repo (and skip make distcheck).
#
# Where we're building for the project that triggered us, we use the existing
# git directory.
#
# The _inst directory is the prefix, it's passed on to the next job.
#
.build-template:
  extends:
    - .fdo.distribution-image@arch
  before_script:
    - |
      if [ "$PROJECT_NAME" != "$CI_JOB_NAME" ]; then
        rm -rf _gitdir;
        git clone --depth 1 $GIT_URL _gitdir;
        pushd _gitdir;
      fi
  script:
    - export PKG_CONFIG_PATH="$CI_PROJECT_DIR/_inst/lib/pkgconfig:$CI_PROJECT_DIR/_inst/share/pkgconfig:"
    - export LD_LIBRARY_PATH="$CI_PROJECT_DIR/_inst/lib"
    - mkdir -p $CI_PROJECT_DIR/_inst
    - autoreconf -ivf
    - mkdir _builddir
    - pushd _builddir > /dev/null
    - ../configure --disable-silent-rules $CONFIGURE_ARGS
    - make
    - |
      if [ "$PROJECT_NAME" == "$CI_JOB_NAME" ]; then
        make check && make distcheck;
      fi
    - make install
  variables:
    GIT_URL: https://gitlab.freedesktop.org/xorg/lib/$CI_JOB_NAME
    CONFIGURE_ARGS: "--prefix=$CI_PROJECT_DIR/_inst/"
    FDO_DISTRIBUTION_TAG: $OUR_DISTRIBUTION_TAG
  artifacts:
    paths:
      - _inst


#
# libX* build jobs
#
# These jobs are generated, see .gitlab-ci/build-libXall.template
# .gitlab-ci/build-libXall.template.config.yaml for the source files.
#
# The goal of these jobs is to have one place for all the libX* repositories
# to do some basic CI build testing. Those repositories will merely trigger
# this pipeline and otherwise have no custom code that needs to be maintained.
#
# This needs to be generated - each library has a set of dependencies and we need to build those first.
# But we don't want to build all libraries every time, so each job has a large
# regex to trigger only those builds a libX* actually relies on.
{#
 # Rather annoying: Gitlab supports a DAG through needs: but still relies on stages.
 # And we can't build dependencies in parallel because we can't merge the
 # artifacts that way.
 # So: each library is in its own stage and we pass the _inst directory through
 # to the next job. Where a job isn't triggered, the stage just won't appear.
 #
 # Job names have to match CI_PROJECT_NAME and all those are lowercase but our
 # config file uses the proper libXfoo spelling. So there's a bunch of lower()
 # filters below and the regex is case insensitive.
 #}
{# init a directory with the library name as key #}
{% set deptree = {} %}
{% for lib in libraries %}
{% set d = { lib.name : {'dependencies': [], 'used-by': [] }} %}
{% do deptree.update(d) %}
{% endfor %}

{# recursively run through each librarie's deps and add them to the list #}
{% for lib in libraries %}
{% do deptree[lib.name]['used-by'].append(lib.name) %}
{% if lib.requires %}
{% for dep in lib.requires recursive %}
 {# add the lib to its own used-by to make the PROJECT_NAME regex generation simpler #}
 {% do deptree[dep]['used-by'].append(lib.name) %}
 {% do deptree[lib.name]['dependencies'].append(dep) %}
 {# equivalent to first = [l for l in libraries if l.name == dep][0] #}
 {% set first = libraries|selectattr('name', 'equalto', dep)|first %}
 {% do loop(first.requires)%}
{% endfor %}
{% endif %}
{% endfor %}

{# Now create the actual job definitions #}
{% for lib in deptree %}
{{lib|lower}}:
  stage: {{lib}}
  extends:
    - .build-template
{% if deptree[lib]['dependencies'] %}
  needs:
{% for dependency in deptree[lib]['dependencies']|unique %}
    - {{dependency|lower}}
{% endfor %}
{% endif %}
  rules:
    - if: $PROJECT_NAME =~ /{{deptree[lib]['used-by']|unique|join('|')}}/i

{% endfor %}

